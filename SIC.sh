#!/bin/bash
#compiled from many other, but, written by hackzo the clown
#reachable @ envs.stroud@gmail.com

#This sets up the 'usage' function which gives a message about usage then loops to main
function usage()
{	clear 2>/dev/null
	echo " "
	echo " ____   ____    _    _   _   ___ _   _      _       ____    _    _   _ "
	echo "/ ___| / ___|  / \  | \ | | |_ _| \ | |    / \     / ___|  / \  | \ | |"
	echo "\___ \| |     / _ \ |  \| |  | ||  \| |   / _ \   | |     / _ \ |  \| |"
	echo " ___) | |___ / ___ \| |\  |  | || |\  |  / ___ \  | |___ / ___ \| |\  |"
	echo "|____/ \____/_/   \_\_| \_| |___|_| \_| /_/   \_\  \____/_/   \_\_| \_|"
	printf "\nI hope this tool aids someone in speeding up their efforts and strategy 
during capture the flag contests. 
Maybe in the future, aiding in automated pentesting as well.
This tool is made to be used on a standard Kali image 
and relies heavily on other installed utilities.\n\n"
read -p "Press any key to continue... " -n1 -s
clear 2>/dev/null

main
}

#This sets up the 'sys_enum' function for remote SYSTEM ENUMERATION
function sys_enum()
{	clear 2>/dev/null
	echo ' ______   ______    _____ _   _ _   _ __  __ '
	echo '/ ___\ \ / / ___|  | ____| \ | | | | |  \/  |'
	echo '\___ \\ V /\___ \  |  _| |  \| | | | | |\/| |'
	echo ' ___) || |  ___) | | |___| |\  | |_| | |  | |'
	echo '|____/ |_| |____/  |_____|_| \_|\___/|_|  |_|'
	printf "\nSystem Enumeration\n"
	printf "\n\nThis module enumerates remote system information and appends it to a textfile.\n"
	printf "\nIt is structured in a way that is broken into 'Levels' the higher the level, the more agressive.\n"
	printf "\nNONE OF THIS IS STEALTHY!! 
	
1. Verbose nmap with no arguements.
2. Adds OS and service version info, traceroute and scripts against services.
3. Performs above, but, against ALL TCP ports. (Takes forever)
4. Performs above AND adds all UDP ports . (EVEN LONGER)
5. Adds 'default' tagged vulnerability scans.\n\n"
confirm
clear 2>/dev/null
outfile 
clear 2>/dev/null
usr_details | tee -a $outfile
clear 2>/dev/null
target_sel
clear 2>/dev/null
PS3="Please select a level. 6 provides a Level Recap

This menu loops until Quit (7) is selected:"
	options=("Level 1" "Level 2" "Level 3" "Level 4" "Level 5" "Help" "Quit")
	select opt in "${options[@]}"
	do
		case $opt in
			"Level 1")
				nmap -vvv $target | tee -a $outfile
				;;
			"Level 2")
				nmap -v -sS -A -T4 $target | tee -a $outfile
				;;
			"Level 3")
				nmap -v -sS -p- -A -T4 $target | tee -a $outfile
				;;
			 "Level 4")
				nmap -v -sU -sS -p- -A -T4 $target | tee -a $outfile
				;;
			 "Level 5")
				nmap -v -sU -sS -sC -p- -A -T4 $target | tee -a $outfile
				;;
			 "Help")
				clear 2>/dev/null
				printf "\nLEVEL RECAP\n
1. Verbose nmap with no arguements.
2. Adds OS and service version info, traceroute and scripts against services.
3. Performs above, but, against ALL TCP ports. (Takes forever)
4. Performs above AND adds all UDP ports. (EVEN LONGER)
5. Adds 'default' tagged vulnerability scans.\n\n"
				;;
			 "Quit") 
				clear 2>/dev/null
				echo "Done, output saved to $outfile" 
				sleep 5
				clear 2>/dev/null
				break
				main
				;;
			*) clear echo Invalid Level;;
		esac
	done
	main
}		

####################################
###User, and output Functions#######
####################################
function target_sel()
#This asks for a target. Unsanitary IP address is expected.
{	read -p 'Please enter the target ip : ' target
#I need to massage this and implement some sanitization, but, expand to include dns names. 
}
function confirm() 
#Asks to Continue, or loops back to main function 
{	while true; do
    read -p "Continue Y/n?" yn
    case $yn in
        [Yy]* ) break;;
        [Nn]* ) clear 2>/dev/null
				main;;
        * ) echo "Please answer yes or no.";;
    esac
done
}
function usr_details()
#This will create a function that will setup who is using the program for op notes
{ printf "Please privide a name for logging purposes. 
This keeps honest people honest and will CYA if something squishes\n"
	#This creates the variable usrname which sloppily stores the name of the operator
	read -p 'Operator Name : ' usrname
	printf "The Operator is $usrname" > $outfile
	}
function outfile()		
#This will create a variable called outfile 
{	printf "Please provide a path to which the output will be saved. I.e /tmp/output.txt\n"
	read -p 'Path to outfile : ' outfile
}
#This sets up the 'Main' function
function main()
{	echo " "
	echo " ____   ____    _    _   _   ___ _   _      _       ____    _    _   _ "
	echo "/ ___| / ___|  / \  | \ | | |_ _| \ | |    / \     / ___|  / \  | \ | |"
	echo "\___ \| |     / _ \ |  \| |  | ||  \| |   / _ \   | |     / _ \ |  \| |"
	echo " ___) | |___ / ___ \| |\  |  | || |\  |  / ___ \  | |___ / ___ \| |\  |"
	echo "|____/ \____/_/   \_\_| \_| |___|_| \_| /_/   \_\  \____/_/   \_\_| \_|"
	
	printf "\nSIC - Scan In a Can\n\n"
	
	PS3='Please enter your choice: '
	options=("Usage" "System Enumeration" "Service Enumeration" "External Utilities" "Cleartext Credentials" "Quit")
	select opt in "${options[@]}"
	do
		case $opt in
			"Usage")
				usage
				;;
			"System Enumeration")
				sys_enum
				;;
			"Service Enumeration")
				serv_enum
				;;
			 "External Utilities")
				ext_util
				;;
			 "Cleartext Credentials")
				cleartext
				;;
			 "Quit") 
				break
				exit 1
				;;
			*) echo invalid option;;
		esac
	done
}

main

